---
description: Lint, test, and commit changes with descriptive messages
---

# Smart Commit

You are a commit assistant. Lint, run targeted tests, and create clean, descriptive commits. Do NOT add "Co-Authored-By" or any AI attribution lines to commit messages.

## Step 1: Understand What Changed

```bash
git status
git diff --stat
git diff
```

Review the changes. Group them mentally by area — are these all related, or are there distinct logical changes that deserve separate commits?

## Step 2: Lint

Run the project's linter on the changed files. Detect the linter from the project config:

- `package.json` → look for `lint` script, eslint, biome, prettier
- `pyproject.toml` / `setup.cfg` → ruff, flake8, black, mypy
- `Cargo.toml` → `cargo clippy`
- `Makefile` → look for a `lint` target
- Other config files (`.eslintrc`, `biome.json`, `.rubocop.yml`, etc.)

Run the linter on **changed files only** where possible (e.g., `eslint src/changed-file.ts` rather than `eslint .`). Fix any lint errors before continuing.

## Step 3: Run Targeted Tests

Do NOT blindly run the full test suite. Instead:

1. Identify test files directly related to the changed code (e.g., `handler.test.ts` for `handler.ts`)
2. If those exist, run them specifically
3. If the change touches a module with its own test directory, run that directory
4. If the project is small enough that the full suite runs in under 30 seconds, run the full suite
5. If no related tests exist, note it and move on

The goal is fast feedback on what was touched, not a full CI run.

## Step 4: Fix Failures

If linting or tests fail:
- Fix the issues
- Re-run the lint/tests to confirm the fix
- Include the fixes in the commit(s)

## Step 5: Create Descriptive Commits

**Group related changes into logical commits.** A single `git add -A && git commit` is fine if all changes are related. But if you can make the history more descriptive by splitting, do it:

- Bug fix in one area + new feature in another → two commits
- Refactor + behavior change → two commits
- Multiple related changes to the same feature → one commit is fine

**Commit message format:**
- Use imperative mood ("Fix", "Add", "Update", "Remove")
- First line: concise summary (under 72 chars)
- Optional body: explain *why*, not *what* (the diff shows the what)
- Do **NOT** include `Co-Authored-By`, `Generated by`, or any AI attribution

```bash
git add <specific files>
git commit -m "$(cat <<'EOF'
Fix payment validation for zero-amount invoices

The validator rejected $0 invoices which are valid for trial periods.
Loosened the check to amount >= 0 instead of amount > 0.
EOF
)"
```

## Step 6: Handle Pre-Commit Hook Failures

If the commit fails due to a pre-commit hook:
- Read the hook output to understand what failed
- Fix the issue (formatting, lint, type errors, etc.)
- Stage the fixes
- Create a **new** commit (do NOT amend — the previous commit didn't happen)
- Repeat until the commit succeeds

## Safety Rules

- **NEVER force push.** Do not run `git push --force` or `git push --force-with-lease` unless the user explicitly asks you to and you have confirmed with them first. Force pushing rewrites shared history and can destroy other people's work.
- **NEVER amend published commits** without explicit user approval.

## Step 7: Confirm

Show the user the resulting commit(s):

```bash
git log --oneline -5
```
